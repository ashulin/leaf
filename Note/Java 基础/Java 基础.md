# Java 基础

> Java基于C++、Simula-67、SmallTalk等语言开发；

## 面向对象

> 面向对象程序设计：Object-Oriented Programming（OOP）

### 类和对象

- 类是对象的抽象，对象是类的具体
- 类是定义了对象的模板
- 类成为对象——实例化
    - 栈保存名字和堆地址
    
    - 堆保存分配后的对象数据
    
    - 通过栈的引用取到值，值为堆地址，因此可取得分配的对象
    
    - *new* 强制分配内存空间
    
    - 类成为对象
      
        - 类先被编译成字节码文件(.class)
            - 前4位 模数 检测是否是java的.class文件
            - 再后4位 版本号
        - 加载到JVM
            - 系统类加载
            - 扩展类加载
            - 自定义类加载
        - 连接
        - 初始化
        - 实例化

### 类

#### 变量

##### 属性（成员变量）

在类里，但在所有方法之外定义的变量，被所有方法共享的变量

- 类属性：静态变量&类名调用
- 实例属性：非静态变量&引用名调用
- 成员变量在声明时如果没有定义值，则JVM会默认赋值；但局部变量不会

    - Boolean false
    - Char '\u0000'(null)
    - byte (byte)0
    - short (short)0
    - int 0
    - long 0L
    - float 0.0f
    - double 0.0d
- 类变量在方法区的静态池，成员变量在堆内存，局部变量在栈内存

##### 局部变量

在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。

#### 方法

> [访问修饰符] {其他修饰符} <方法返回值的类型> <方法名> ([args]){}

- 在有返回值声明的方法中return的值的类型必须与声明类型一致
- 在void方法上，可以使用return；可以直接中断当然方法，继续执行

##### 特殊方法

- 主方法(mian方法): 程序的入口，一个Class只能有一个
- 如果声明了一个带参数的构造方法，那么JVM不会再自动产生无参的构造器
- 代码域{}: 实例化以后才被加载
- 静态域static{}: 常用于初始化，类加载的时候进行加载

## 数据类型

### 运算

- 如果整数型保存浮点数类型，那么小数点后数据全部舍弃。
- 相对更大的类型与相对更小的类型运算，获得相对更大的类型
- 负数原码--反码--补码 **不要将负数交给没有符号位的数据类型保存**
- 当char 单独打印时会把所存放的数字当做ASCII码表的键，打印相应的值；
    但如果两个char值进行运算，无论是否为数字都会将两个char转成ASCII码
    中对应的数字进行运算

### 转换

- 长字节类型转化为短字节类型时，直接剪去超出的字节
- 短字节类型转化为长字节类型时
    - 正整数向少的bit位填充0
    - 负整数向少的bit位填充1

## String

- 值不可以被改变，一旦改变则表示重新生成新的对象
- .substring(<start>[,<end>]): 返回strat下标以后(到end结束)的字符串
- substring在jdk1.6中因为返回的String对象仍然引用分割前的字符串数组，可能导致内存泄露

### 字符串连接

#### `+`拼接字符串

实际为先new一个StringBuilder对象，再用append方法扩展

```
String saito = "saito";
String asuka = saito + ",";
//编译后
String asuka = (new StringBuilder()).append(saito).append(",");
```

#### concat（）

新建一个字符串数组并拷贝需要连接的字符串，再返回一个新的String对象

```java
public String concat(String str) {
    int otherLen = str.length();
    if (otherLen == 0) {
        return this;
    }
    int len = value.length;
    char buf[] = Arrays.copyOf(value, len + otherLen);
    str.getChars(buf, len);
    return new String(buf, true);
}
```

#### StringBuffer和StringBuilder

- 内部字符数组默认长度为给定字符长度**+16**，无参即为16；

- append会直接拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。

- `StringBuffer`是线程安全的，而`StringBuilder`则不是线程安全的。

用时从短到长的对比是：`StringBuilder`<`StringBuffer`<`concat`<`+`

## 六、关键字

### final

**1. 数据**

声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

- 对于基本类型，final 使数值不变；
- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

**2. 方法**

声明方法不能被子类重写。

private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

**3. 类**

声明类不允许被继承。

### static

**1. 静态变量**

- 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。
- 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

**2. 静态方法**

静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。

只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。

**3. 静态语句块**

静态语句块只在类初始化时运行一次。

**4. 静态内部类**

非静态内部类依赖于外部类的实例，而静态内部类不需要。

静态内部类不能访问外部类的非静态的变量和方法。

**5. 静态导包**

在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。

**6. 初始化顺序**

静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

```
public static String staticField = "静态变量";
static {
    System.out.println("静态语句块");
}
public String field = "实例变量";
{
    System.out.println("普通语句块");
}
```

最后才是构造函数的初始化。

```
public InitialOrderTest() {
    System.out.println("构造函数");
}
```

存在继承的情况下，初始化顺序为：

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造函数）
- 子类（实例变量、普通语句块）
- 子类（构造函数）



### transient

阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。

instanceof、volatile、synchronized、const 原理及用法。

## 七、泛型

## 八、异常

Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： **Error** 和 **Exception**。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：

- **受检异常** ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；
- **非受检异常** ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。

