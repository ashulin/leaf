# HTTP

HTTP 协议，是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。

## 特点

- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

- 数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。

- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

    > 主要指的是不使用 Keep-Alive 机制的情况下。

- 无状态：HTTP 协议是无状态协议。无状态，是指协议对于事务处理没有记忆能力。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

    > 无状态，所以更容易做服务的扩容，支撑更大的访问量。

- 支持 B/S 及 C/S 模式。

    > 另外，HTTP 协议已经不仅仅使用在浏览器上。在前后端分离的架构中，又或者微服务架构的内部通信中，HTTP 因为其数据格式的通用性，和语言无关，被大规模使用。

## 运行过程

1. DNS 解析(通过访问的域名找出其 IP 地址，递归搜索)。

2. HTTP 请求，当输入一个请求时，建立一个 Socket 连接发起 TCP的 3 次握手。

    > 如果是 HTTPS 请求，会略微有不同。等到 HTTPS 小节，我们在来讲。

3. 客户端向服务器发送请求命令（一般是 GET 或 POST 请求）。

    > 这个是补充内容，面试一般不用回答。
    >
    > 客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
    >
    > 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定 IP 地址的 MAC 地址，然后发送 ARP 请求查找目的地址，如果得到回应后就可以使用 ARP 的请求应答交换的 IP 数据包现在就可以传输了，然后发送 IP 数据包到达服务器的地址。

4. 客户端发送请求头信息和数据。

5. 服务器发送应答头信息。

6. 服务器向客户端发送数据。

7. 服务器关闭 TCP 连接（4次挥手）。

    > 这里是否关闭 TCP 连接，也根据 HTTP Keep-Alive 机制有关。
    >
    > 同时，客户端也可以主动发起关闭 TCP 连接。

8. 客户端根据返回的 HTML、CSS、JS 进行渲染。

## 长连接、短连接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

> Connection:keep-alive

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**

## HTTP 基本格式

### **HTTP 请求格式**

![HTTP请求报文](https://pic002.cnblogs.com/images/2012/426620/2012072810301161.png)

- 请求行：
    - 请求方法：如PUT、POST
    - 请求URL：URL地址
    - 协议版本：即HTTP协议版本号；
- 请求头部：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部。
    - HOST ，请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。
    - User-Agent ，产生请求的浏览器类型。服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础。该信息由你的浏览器来定义，并且在每个请求中自动发送等等
    - Accept：客户端可识别的内容类型列表。
    - **Cookie**：Cookie信息；
    - **Referer**：表示该请求从哪个URL发来的；
    - Content-Type：请求的数据类型
- 空行：请求头部后面的空行是必须的。
- 请求数据：也叫主体，可以添加任意的其他数据。

### **HTTP 响应格式**

- 状态行：由 HTTP 协议版本号、状态码、状态消息三部分组成。
- 消息报头：用来说明客户端要使用的一些附加信息。
- 空行：消息报头后面的空行是必须的。
- 响应正文：服务器返回给客户端的文本信息。

## 请求方式

- GET: 对服务器资源的简单请求。
- POST: 用于发送包含用户提交数据的请求。
- HEAD：类似于 GET 请求，不过返回的响应中没有具体内容，用于获取报头。
- PUT：传说中请求文档的一个版本。
- DELETE：发出一个删除指定文档的请求。
- TRACE：发送一个请求副本，以跟踪其处理进程。
- OPTIONS：返回所有可用的方法，检查服务器支持哪些方法。
- CONNECT：用于 SSL 隧道的基于代理的请求。

**GET 和 POST 的区别？**

| 请求方式 | 数据位置            | 明文密文 | 数据安全 | 长度限制          | 应用场景 |
| -------- | ------------------- | -------- | -------- | ----------------- | -------- |
| GET      | HTTP 请求的 path 中 | 明文     | 不安全   | 长度较小，一般 2k | 查询数据 |
| POST     | HTTP 请求 body 中   | 可明可密 | 安全     | 支持较大数据传输  | 修改数据 |

- GET 请求可被缓存；POST 请求不会被缓存。

- GET 请求可被收藏为书签；POST 不能被收藏为书签。

- 【非常有趣】参见 [《99%的人理解错 HTTP 中 GET 与 POST 的区别》](https://www.oschina.net/news/77354/http-get-post-different)

    > - 对于 GET 方式的请求，浏览器会把 HTTP header 和 data 一并发送出去，服务器响应 200（返回数据）。
    > - 而对于 POST，浏览器先发送 header ，服务器响应 100 continue ，浏览器再发送 data ，服务器响应 200 ok（返回数据）。
    >
    > 也就是说，GET 只需要汽车跑一趟就把货送到了，而 POS T得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。
    >
    > ps：不过要注意，POST 具体发几次，也和浏览器的实现有关系。例如：Firefox 只发一次。
    > ps2：据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。

## 状态码

- 1×× : 请求处理中，请求已被接受，正在处理
- 2×× : 请求成功，请求被成功处理
    - 200 OK // 客户端请求成功
- 3×× : 重定向，要完成请求必须进行进一步处理
    - 301 Moved Permanently // 永久重定向,使用域名跳转
    - 302 Found // 临时重定向,未登陆的用户访问用户中心重定向到登录页面
    - **303 See Other**：重定向到其它的页面，目标的URL通过响应报文头在Location
    - **304 Not Modified**：表示请求的资源未修改，请客户端使用本地缓存
- 4×× : 客户端错误，请求不合法
    - 400 Bad Request // 客户端请求有语法错误，不能被服务器所理解
    - 401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
    - 403 Forbidden // 服务器收到请求，但是拒绝提供服务
    - 404 Not Found // 请求资源不存在，eg：输入了错误的 URL
- 5×× : 服务器端错误，服务器不能处理合法请求
    - 500 Internal Server Error // 服务器发生不可预期的错误
    - 503 Server Unavailable // 服务器当前不能处理客户端的请求，一段时间后可能恢复正常

完整的状态码列表，可以看看 [《HTTP 状态码》](https://zh.wikipedia.org/zh-hans/HTTP状态码) 文章。

## HTTP、TCP、Socket 的关系

- TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族。
- HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议。
- Socket 是 TCP/IP 网络的 API ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。

综上所述：

- 需要 IP 协议来连接网络
- TCP 是一种允许我们安全传输数据的机制，使用 TCP 协议来传输数据的 HTTP 是 Web 服务器和客户端使用的特殊协议。
- HTTP 基于 TCP 协议，所以可以使用 Socket 去建立一个 TCP 连接。

## Cookies 和 Session 的区别

- Session 在服务器端，Cookie 在客户端（浏览器）。

    > Session 默认被存在在服务器的一个文件里（不是内存）。

- Session 的运行依赖 sessionid ，而 sessionid 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie ，同时 session 也会失效。但是，可以通过其它方式实现，比如在 url 参数中传递 sessionid 。

- Session 可以放在文件、数据库、或内存中都可以。

- 【关键】**用户验证这种场合一般会用 Session** 。

# DNS

- 域名解析，[www.xxx.com](http://www.xxx.com/) 转换成 IP ，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。
- DNS 协议运行在 UDP 协议之上，使用端口号 53 。

## 主机解析域名的顺序？

1. 浏览器缓存
2. 找本机的 hosts 文件
3. 路由缓存
4. 找 DNS 服务器(本地域名、顶级域名、根域名)
    - [迭代查询](https://blog.csdn.net/wuchuanpingstone/article/details/6720723)
    - [递归查询](https://blog.csdn.net/wuchuanpingstone/article/details/6720723)

## DNS 使用什么协议？

> 参见 [《DNS使用的是 TCP 协议还是 UDP 协议》](https://benbenxiongyuan.iteye.com/blog/1088085) 文章。

既使用 TCP 又使用 UDP 。

- 区域传送时使用 TCP 协议。

    > - 辅域名服务器会定时（一般时 3 小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用 TCP 而不是 UDP ，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。
    > - TCP 是一种可靠的连接，保证了数据的准确性。

- 域名解析时使用 UDP 协议。

    > - 客户端向 DNS 服务器查询域名，一般返回的内容都不超过 512 字节，用 UDP 传输即可。
    >
    >     > UDP 报文的最大长度为 512 字节。
    >
    > - 不用经过 TCP 三次握手，这样 DNS 服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向 DNS 服务器查询的时候使用 TCP ，但事实上，很多 DNS 服务器进行配置的时候，仅支持 UDP 查询包。

[WIKIPEDIA × List of HTTP header fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)

[MDN × HTTP消息](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages)